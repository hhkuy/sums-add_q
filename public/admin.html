<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quiz Manager Admin Panel</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Bootstrap Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <!-- Custom Styles -->
  <style>
    body {
      background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
      font-family: 'Roboto', sans-serif;
      padding-top: 20px;
      padding-bottom: 20px;
    }
    .container-custom {
      max-width: 1200px;
      background-color: #fff;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      margin: auto;
    }
    h1 {
      text-align: center;
      margin-bottom: 30px;
      color: #343a40;
      font-weight: 600;
    }
    .card-section {
      margin-bottom: 30px;
    }
    .card-section .card-header {
      background-color: #343a40;
      color: #fff;
      font-size: 1.25em;
      border-top-left-radius: 15px;
      border-top-right-radius: 15px;
    }
    .btn-custom {
      width: 100%;
      padding: 12px;
      font-size: 1.1em;
      border-radius: 50px;
      transition: all 0.3s ease;
    }
    .btn-custom:hover {
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
    }
    #loadMessage {
      margin-top: 15px;
    }
    /* Bulk Reorder Styles */
    .group-card {
      border: 1px solid #dee2e6;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 15px;
      background-color: #f8f9fa;
    }
    .group-card h5 {
      margin-bottom: 10px;
      font-weight: 600;
      color: #495057;
    }
    .group-actions button {
      margin-right: 10px;
    }
    /* Floating Scroll Buttons */
    #floatScrollBtn, #floatSaveBtn {
      position: fixed;
      width: 50px;
      height: 50px;
      background: #4a90e2;
      color: #fff;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      z-index: 999;
    }
    #floatScrollBtn:hover, #floatSaveBtn:hover {
      opacity: 0.8;
    }
    /* ÿßŸÑÿ≤ÿ± ÿßŸÑÿπÿßÿ¶ŸÖ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä ŸÑŸÑŸÜŸÇŸÑ */
    #floatScrollBtn {
      top: 50%;
      right: 30px;
      transform: translateY(calc(-50% - 30px));
    }
    /* ÿ≤ÿ± ÿßŸÑŸÜŸÇŸÑ ÿßŸÑÿ•ÿ∂ÿßŸÅŸä */
    #floatSaveBtn {
      top: 50%;
      right: 30px;
      transform: translateY(calc(-50% + 30px));
      background: #dc3545;
    }
    /* Modal Overrides */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    .modal-box {
      background: #fff;
      border-radius: 8px;
      padding: 20px;
      max-width: 400px;
      width: 90%;
      text-align: center;
    }
    .modal-box h3 { margin-bottom: 20px; font-size: 1.1rem; color: #333; }
    .modal-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container-custom">
    <h1><i class="bi bi-journal-text"></i> Quiz Manager Admin Panel</h1>
    
    <!-- Manage Topics Section -->
    <div class="card card-section">
      <div class="card-header">Manage Topics</div>
      <div class="card-body">
        <div class="mb-3">
          <button class="btn btn-primary btn-custom" onclick="loadTopics()">Load topics.json</button>
        </div>
        <div id="topicsList"></div>
        <div class="row g-2 mt-3">
          <div class="col-md-4">
            <input type="text" id="newTopicName" class="form-control" placeholder="Topic Name...">
          </div>
          <div class="col-md-4">
            <input type="text" id="newTopicDesc" class="form-control" placeholder="Topic Description...">
          </div>
          <div class="col-md-4">
            <button class="btn btn-primary btn-custom" onclick="addTopic()">Add Topic</button>
          </div>
          <div class="col-md-4 mt-2">
            <button class="btn btn-success btn-custom" onclick="saveTopics()">Save topics.json</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Subtopic Questions Manager Section -->
    <div class="card card-section">
      <div class="card-header">Subtopic Questions Manager</div>
      <div class="card-body">
        <div class="mb-3">
          <select id="subtopicSelect" class="form-select"></select>
        </div>
        <div class="mb-3">
          <button class="btn btn-primary btn-custom" onclick="loadSubtopic()">Load Questions</button>
        </div>
        <!-- ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ£ŸÉŸäÿØ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© -->
        <div id="loadMessage"></div>
        <hr>
        <div class="row g-2 mb-3">
          <div class="col-md-6">
            <button class="btn btn-primary btn-custom" onclick="convertAndAppend()">Convert &amp; Append</button>
          </div>
          <div class="col-md-6">
            <button class="btn btn-success btn-custom" id="saveQuestionsBtn" onclick="saveSubtopic()">Save Questions</button>
          </div>
        </div>
        <!-- ÿ≤ÿ± ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÄ IDs ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© -->
        <div class="mb-3">
          <button class="btn btn-info btn-custom" onclick="addIdsToAllFiles()">
            Add IDs to All Questions (All Files)
          </button>
        </div>
      </div>
    </div>
    
    <!-- Edit Questions Section -->
    <div class="card card-section">
      <div class="card-header">Edit Questions</div>
      <div class="card-body">
        <div class="mb-3">
          <input type="number" id="jumpToQuestion" class="form-control" placeholder="Enter question number to jump" min="1">
        </div>
        <div class="mb-3">
          <button class="btn btn-primary btn-custom" onclick="jumpToQuestion()">Jump to Question</button>
        </div>
        <div id="questionsEditList"></div>
      </div>
    </div>
    
    <!-- Bulk Reorder Questions Section -->
    <div class="card card-section">
      <div class="card-header">Bulk Reorder Questions</div>
      <div class="card-body">
        <div class="mb-3">
          <button class="btn btn-primary btn-custom" onclick="loadBoldGroups()">Load Bold Groups</button>
        </div>
        <div id="boldGroupsList"></div>
      </div>
    </div>
  </div>
  
  <!-- Floating Buttons -->
  <button id="floatScrollBtn" onclick="toggleScroll()">‚Üì</button>
  <button id="floatSaveBtn" onclick="scrollToSaveQuestions()">üíæ</button>
  
  <!-- Custom modals for alert/confirm/prompt -->
  <div class="modal-overlay" id="alertOverlay">
    <div class="modal-box">
      <h3 id="alertMsg"></h3>
      <div class="modal-buttons">
        <button class="btn btn-primary" id="alertOkBtn">OK</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="confirmOverlay">
    <div class="modal-box">
      <h3 id="confirmMsg"></h3>
      <div class="modal-buttons">
        <button class="btn btn-primary" id="confirmYesBtn">Yes</button>
        <button class="btn btn-danger" id="confirmNoBtn">No</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="promptOverlay">
    <div class="modal-box">
      <h3 id="promptMsg"></h3>
      <input type="text" id="promptInput" class="form-control mb-3">
      <div class="modal-buttons">
        <button class="btn btn-primary" id="promptOkBtn">OK</button>
        <button class="btn btn-secondary" id="promptCancelBtn">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Bootstrap 5 JS Bundle -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
  <script>
    // Modal Functions
    let alertOverlay = document.getElementById('alertOverlay');
    let alertMsg = document.getElementById('alertMsg');
    let alertOkBtn = document.getElementById('alertOkBtn');
    
    let confirmOverlay = document.getElementById('confirmOverlay');
    let confirmMsg = document.getElementById('confirmMsg');
    let confirmYesBtn = document.getElementById('confirmYesBtn');
    let confirmNoBtn = document.getElementById('confirmNoBtn');
    
    let promptOverlay = document.getElementById('promptOverlay');
    let promptMsg = document.getElementById('promptMsg');
    let promptInput = document.getElementById('promptInput');
    let promptOkBtn = document.getElementById('promptOkBtn');
    let promptCancelBtn = document.getElementById('promptCancelBtn');
    
    function customAlert(message) {
      return new Promise(resolve => {
        alertMsg.textContent = message;
        alertOverlay.style.display = 'flex';
        alertOkBtn.onclick = () => {
          alertOverlay.style.display = 'none';
          resolve();
        };
      });
    }
    function customConfirm(message) {
      return new Promise(resolve => {
        confirmMsg.textContent = message;
        confirmOverlay.style.display = 'flex';
        confirmYesBtn.onclick = () => {
          confirmOverlay.style.display = 'none';
          resolve(true);
        };
        confirmNoBtn.onclick = () => {
          confirmOverlay.style.display = 'none';
          resolve(false);
        };
      });
    }
    function customPrompt(message, defVal) {
      return new Promise(resolve => {
        promptMsg.textContent = message;
        promptInput.value = defVal || '';
        promptOverlay.style.display = 'flex';
        promptOkBtn.onclick = () => {
          let val = promptInput.value;
          promptOverlay.style.display = 'none';
          resolve(val);
        };
        promptCancelBtn.onclick = () => {
          promptOverlay.style.display = 'none';
          resolve(null);
        };
      });
    }
    
    window.alert = async function(msg) {
      await customAlert(msg);
    };
    window.confirm = async function(msg) {
      return customConfirm(msg);
    };
    window.prompt = async function(msg, defVal) {
      return customPrompt(msg, defVal);
    };
    
    // Floating Buttons
    let scrollState = false;
    function toggleScroll(){
      let btn = document.getElementById('floatScrollBtn');
      if(!scrollState){
        window.scrollTo({top: document.body.scrollHeight, behavior:'smooth'});
        btn.textContent = '‚Üë';
        scrollState = true;
      } else {
        window.scrollTo({top: 0, behavior:'smooth'});
        btn.textContent = '‚Üì';
        scrollState = false;
      }
    }
    function scrollToSaveQuestions(){
      let saveBtn = document.getElementById('saveQuestionsBtn');
      if(saveBtn){
        saveBtn.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }
    
    // Global Variables
    let cachedTopics = [];
    let topicsSha = null;
    let currentSubtopicPath = null;
    let currentSubtopicSha = null;
    let currentQuestions = [];
    
    function showSaveMessage(){
      alert("Operation completed.");
    }
    
    // Load/Save Topics Functions
    async function loadTopics(){
      try{
        let r = await fetch('/api/topics');
        let j = await r.json();
        if(!j.success) return;
        cachedTopics = j.topics;
        topicsSha = j.sha;
        renderTopics();
        fillSubtopics();
      } catch(e){}
    }
    async function saveTopics(){
      let conf = await confirm("Are you sure you want to save topics?");
      if(!conf) return;
      try{
        let body = { topics: cachedTopics, sha: topicsSha };
        let r = await fetch('/api/topics',{
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify(body)
        });
        let j = await r.json();
        if(!j.success){ alert("Saving topics failed: " + j.error); return; }
        showSaveMessage();
      } catch(e){}
    }
    
    function renderTopics(){
      let list = document.getElementById('topicsList');
      list.innerHTML = '';
      cachedTopics.forEach((t, idx) => {
        let d = document.createElement('div');
        d.className = "p-3 mb-2 border rounded";
        d.innerHTML = `<strong>${t.topicName}</strong> (sub: ${t.subTopics ? t.subTopics.length : 0})<br>${t.description || ''}`;
        let upBtn = document.createElement('button');
        upBtn.className = 'btn btn-secondary btn-sm me-1';
        upBtn.textContent = '‚ñ≤';
        upBtn.onclick = () => {
          if(idx > 0){
            [cachedTopics[idx-1], cachedTopics[idx]] = [cachedTopics[idx], cachedTopics[idx-1]];
            renderTopics();
            fillSubtopics();
          }
        };
        d.appendChild(upBtn);
    
        let downBtn = document.createElement('button');
        downBtn.className = 'btn btn-secondary btn-sm me-1';
        downBtn.textContent = '‚ñº';
        downBtn.onclick = () => {
          if(idx < cachedTopics.length - 1){
            [cachedTopics[idx], cachedTopics[idx+1]] = [cachedTopics[idx+1], cachedTopics[idx]];
            renderTopics();
            fillSubtopics();
          }
        };
        d.appendChild(downBtn);
    
        let delBtn = document.createElement('button');
        delBtn.className = 'btn btn-danger btn-sm me-1';
        delBtn.textContent = 'Delete';
        delBtn.onclick = async () => {
          let c = await confirm("Delete this topic?");
          if(c){
            cachedTopics.splice(idx, 1);
            renderTopics();
            fillSubtopics();
          }
        };
        d.appendChild(delBtn);
    
        let edBtn = document.createElement('button');
        edBtn.className = 'btn btn-warning btn-sm me-1';
        edBtn.textContent = 'Edit';
        edBtn.onclick = async () => {
          let newName = await prompt("Topic name:", t.topicName);
          if(newName !== null && newName !== '') t.topicName = newName;
          let newDesc = await prompt("Topic desc:", t.description || '');
          if(newDesc !== null) t.description = newDesc;
          renderTopics();
          fillSubtopics();
        };
        d.appendChild(edBtn);
    
        if(t.subTopics && t.subTopics.length > 0){
          t.subTopics.forEach((st, stidx) => {
            let stDiv = document.createElement('div');
            stDiv.className = "ms-3 mt-2";
            stDiv.innerHTML = `${st.name}`;
    
            let subUp = document.createElement('button');
            subUp.className = 'btn btn-secondary btn-sm me-1';
            subUp.textContent = '‚ñ≤';
            subUp.onclick = () => {
              if(stidx > 0){
                [t.subTopics[stidx-1], t.subTopics[stidx]] = [t.subTopics[stidx], t.subTopics[stidx-1]];
                renderTopics();
                fillSubtopics();
              }
            };
            stDiv.appendChild(subUp);
    
            let subDown = document.createElement('button');
            subDown.className = 'btn btn-secondary btn-sm me-1';
            subDown.textContent = '‚ñº';
            subDown.onclick = () => {
              if(stidx < t.subTopics.length - 1){
                [t.subTopics[stidx], t.subTopics[stidx+1]] = [t.subTopics[stidx+1], t.subTopics[stidx]];
                renderTopics();
                fillSubtopics();
              }
            };
            stDiv.appendChild(subDown);
    
            let sdel = document.createElement('button');
            sdel.className = 'btn btn-danger btn-sm me-1';
            sdel.textContent = 'X';
            sdel.onclick = async () => {
              let c = await confirm("Delete subtopic?");
              if(c){
                t.subTopics.splice(stidx, 1);
                renderTopics();
                fillSubtopics();
                if(st.file){
                  await deleteSubtopicFileFromRepo(st.file);
                }
              }
            };
            stDiv.appendChild(sdel);
    
            let sedit = document.createElement('button');
            sedit.className = 'btn btn-warning btn-sm';
            sedit.textContent = 'Edit';
            sedit.onclick = async () => {
              let rename = await prompt("Subtopic name:", st.name);
              if(rename !== null && rename !== ''){
                st.name = rename;
                renderTopics();
                fillSubtopics();
              }
            };
            stDiv.appendChild(sedit);
    
            d.appendChild(stDiv);
          });
        }
    
        let addSt = document.createElement('button');
        addSt.className = 'btn btn-primary btn-sm mt-2';
        addSt.textContent = 'Add Subtopic';
        addSt.onclick = async () => {
          let sbName = await prompt("Subtopic name?");
          if(!sbName) return;
          let fileName = (t.topicName.replace(/\s+/g, '_') + "_" + sbName.replace(/\s+/g, '_')).toLowerCase() + '.json';
          let path = 'data/' + fileName;
          if(!t.subTopics) t.subTopics = [];
          t.subTopics.push({name: sbName, file: path});
          renderTopics();
          fillSubtopics();
        };
        d.appendChild(addSt);
    
        list.appendChild(d);
      });
    }
    
    async function deleteSubtopicFileFromRepo(filePath){
      try{
        let resp = await fetch('/api/delete-file?filePath=' + encodeURIComponent(filePath), {
          method: 'DELETE'
        });
        let j = await resp.json();
        if(!resp.ok || !j.success){
          console.warn("Failed to delete subtopic file", j.error || resp.statusText);
        } else {
          console.log("Subtopic file deleted from repo:", filePath);
        }
      } catch(e){
        console.error("Error deleting subtopic file from repo:", e);
      }
    }
    
    function addTopic(){
      let nm = document.getElementById('newTopicName').value.trim();
      let ds = document.getElementById('newTopicDesc').value.trim();
      if(!nm) return;
      cachedTopics.push({topicName: nm, description: ds, subTopics: []});
      document.getElementById('newTopicName').value = '';
      document.getElementById('newTopicDesc').value = '';
      renderTopics();
      fillSubtopics();
    }
    
    function fillSubtopics(){
      let sel = document.getElementById('subtopicSelect');
      sel.innerHTML = '';
      cachedTopics.forEach(t => {
        if(t.subTopics){
          t.subTopics.forEach(st => {
            let opt = document.createElement('option');
            opt.value = st.file;
            opt.textContent = `[${t.topicName}] - ${st.name}`;
            sel.appendChild(opt);
          });
        }
      });
    }
    
    async function loadSubtopic(){
      let sel = document.getElementById('subtopicSelect');
      if(!sel.value) return;
      currentSubtopicPath = sel.value;
      try{
        let r = await fetch('/api/get-subtopic-file?path=' + encodeURIComponent(currentSubtopicPath));
        let j = await r.json();
        if(!j.success) return;
        currentSubtopicSha = j.sha;
        currentQuestions = j.content;
        document.getElementById('loadMessage').innerHTML = '<div class="alert alert-success" role="alert">Questions loaded successfully!</div>';
        renderEditableQuestions();
      } catch(e){}
    }
    
    function renderEditableQuestions() {
      let container = document.getElementById('questionsEditList');
      container.innerHTML = '';
      
      currentQuestions.forEach((q, index) => {
        // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÜÿµ ÿßŸÑÿ∫ÿßŸÖŸÇ ŸÖŸÜ ÿßŸÑÿ≥ÿ§ÿßŸÑ
        let boldMatch = q.question.match(/<span\s+style=(["'])(?:(?!\1).)*font-weight:\s*bold;?(?:(?!\1).)*\1>(.*?)<\/span>/i);
        let boldPart = boldMatch ? boldMatch[2].trim() : '';
        // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿµŸàÿ±ÿ© ÿ•ŸÜ ŸàŸèÿ¨ÿØÿ™
        let imgMatch = q.question.match(/<img\s+[^>]*src=['"]([^'"]+)['"]/i);
        let currentImage = imgMatch ? imgMatch[1] : "";
        // ÿ•ÿ≤ÿßŸÑÿ© Ÿàÿ≥ŸàŸÖ <br> ŸÖŸÜ ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ
        let textWithoutBr = q.question.replace(/<br\s*\/?>/gi, " ");
        // ÿ•ÿ≤ÿßŸÑÿ© Ÿàÿ≥ŸÖ ÿßŸÑÿµŸàÿ±ÿ© ŸàÿßŸÑŸÜÿµ ÿßŸÑÿ∫ÿßŸÖŸÇ ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÅÿπŸÑŸä
        let textWithoutImg = textWithoutBr.replace(/<img\s+[^>]*>/gi, "").trim();
        let questionText = boldMatch ? textWithoutImg.replace(boldMatch[0], "").trim() : textWithoutImg;
    
        let html = `
          <div class="mb-2">
            <strong>Question ${index + 1}</strong>
            <button class="btn btn-secondary btn-sm" onclick="handleMoveUp(${index})">‚ñ≤</button>
            <button class="btn btn-secondary btn-sm" onclick="handleMoveDown(${index})">‚ñº</button>
            <button class="btn btn-danger btn-sm ms-2" onclick="deleteQuestion(${index})">Delete</button>
          </div>
          <div class="mb-2">
            <input type="text" class="form-control bold-prefix" data-index="${index}" value="${boldPart}" placeholder="Bold prefix (e.g. Dr. Yasin - Question 5)">
          </div>
          <div class="mb-2">
            <textarea class="form-control question-text" data-index="${index}" rows="3" placeholder="Question text...">${questionText}</textarea>
          </div>
          <div class="mb-2">
            <label>Image:</label>
            <div id="imagePreview-${index}" class="mb-2">
              ${ currentImage ? `<img src="${currentImage}" alt="Image for Q${index+1}" style="max-width:100%; height:auto;" data-filepath="">` : 'No image' }
            </div>
            <input type="file" class="form-control mt-2 image-file" data-index="${index}" accept="image/*">
            <button class="btn btn-danger btn-sm mt-2" onclick="deleteImage(${index})">Delete Image</button>
            <div id="uploadProgress-${index}" class="progress mt-2" style="height:24px; display:none;">
              <div class="progress-bar" style="width:0%;">0%</div>
            </div>
          </div>
          <div id="options-${index}" class="mb-2"></div>
          <div class="mb-2">
            <label>Correct Answer:</label>
            <div id="optionGroup-${index}"></div>
          </div>
          <div class="mb-2">
            <label>Explanation:</label>
            <textarea class="form-control explanation" data-index="${index}" rows="3" style="resize: vertical;" placeholder="Enter explanation...">${q.explanation || ''}</textarea>
          </div>
          <button class="btn btn-primary btn-sm" id="updateBtn-${index}" onclick="saveQuestionChanges(${index})">Update Question</button>`;
    
        let containerDiv = document.createElement('div');
        containerDiv.innerHTML = html;
        containerDiv.id = `q-${index+1}`;
    
        // ÿπÿ±ÿ∂ ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸÖÿπ ÿ≤ÿ± ÿ±ÿßÿØŸäŸà
        let optionGroup = containerDiv.querySelector(`#optionGroup-${index}`);
        q.options.forEach((opt, optIndex) => {
          let groupDiv = document.createElement('div');
          groupDiv.className = "input-group mb-1";
    
          let radio = document.createElement('input');
          radio.type = "radio";
          radio.name = "correctOption_" + index;
          radio.className = "form-check-input";
          radio.style.marginTop = "auto";
          radio.style.marginBottom = "auto";
          radio.value = optIndex;
          if(q.answer === optIndex) radio.checked = true;
          radio.onchange = function() {
            q.answer = parseInt(this.value);
            let opts = [];
            let inputs = optionGroup.querySelectorAll('input[type="text"]');
            inputs.forEach(inp => opts.push(inp.value));
            q.answerText = opts[q.answer] || "";
          };
    
          let optInput = document.createElement('input');
          optInput.type = 'text';
          optInput.value = opt.replace('***', '').trim();
          optInput.className = 'form-control';
          optInput.dataset.index = index;
          optInput.dataset.optIndex = optIndex;
          optInput.oninput = function(){
            if(q.answer === parseInt(this.dataset.optIndex)) {
              q.answerText = this.value;
            }
          };
    
          groupDiv.appendChild(radio);
          groupDiv.appendChild(optInput);
          optionGroup.appendChild(groupDiv);
        });
    
        container.appendChild(containerDiv);
      });
    }
    
    function handleMoveUp(index) {
      if (index > 0) {
        [currentQuestions[index - 1], currentQuestions[index]] = [currentQuestions[index], currentQuestions[index - 1]];
        updateAllQuestionIds();
        renderEditableQuestions();
      }
    }
    function handleMoveDown(index) {
      if (index < currentQuestions.length - 1) {
        [currentQuestions[index], currentQuestions[index + 1]] = [currentQuestions[index + 1], currentQuestions[index]];
        updateAllQuestionIds();
        renderEditableQuestions();
      }
    }
    
    async function saveQuestionChanges(index) {
      try {
        const boldPrefix = document.querySelector(`.bold-prefix[data-index="${index}"]`).value;
        const questionText = document.querySelector(`.question-text[data-index="${index}"]`).value;
        const optionInputs = Array.from(document.querySelectorAll(`#optionGroup-${index} input[type="text"]`));
        const options = optionInputs.map(input => input.value);
        const selectedRadio = document.querySelector(`input[name="correctOption_${index}"]:checked`);
        const correctAnswer = selectedRadio ? parseInt(selectedRadio.value) : 0;
        const explanation = document.querySelector(`.explanation[data-index="${index}"]`).value;
        const newAnswerText = options[correctAnswer] || "";
    
        let imageFileInput = document.querySelector(`.image-file[data-index="${index}"]`);
        let newImageUrl = "";
        if(imageFileInput && imageFileInput.files.length > 0) {
          let progressContainer = document.getElementById(`uploadProgress-${index}`);
          newImageUrl = await uploadImageToGitHub(imageFileInput.files[0], progressContainer, progressContainer.firstElementChild);
          newImageUrl = newImageUrl.url;
        } else {
          let previewDiv = document.getElementById(`imagePreview-${index}`);
          if(previewDiv && previewDiv.querySelector('img')) {
            newImageUrl = previewDiv.querySelector('img').src;
          }
        }
    
        let newQuestion = `<span style="color: darkred; font-weight:bold;">${boldPrefix}</span> ${questionText}`;
        if(newImageUrl) {
          newQuestion += `<br><img src="${newImageUrl}" alt="Image for Q${index+1}" style="max-width:100%; height:auto;">`;
        }
    
        currentQuestions[index] = {
          ...currentQuestions[index],
          question: newQuestion,
          options: options,
          answer: correctAnswer,
          answerText: newAnswerText,
          explanation: explanation
        };
    
        let btn = document.getElementById("updateBtn-" + index);
        btn.innerHTML = "Update Question <i class='bi bi-check-circle-fill text-success'></i>";
        updateAllQuestionIds();
        setTimeout(() => { btn.innerHTML = "Update Question"; }, 2000);
      } catch(e) {
        let btn = document.getElementById("updateBtn-" + index);
        btn.innerHTML = "Update Question <i class='bi bi-x-circle-fill text-danger'></i>";
        setTimeout(() => { btn.innerHTML = "Update Question"; }, 2000);
      }
    }
    
    function deleteQuestion(index) {
      confirm("Delete this question?").then(c => {
        if(c){
          currentQuestions.splice(index, 1);
          updateAllQuestionIds();
          renderEditableQuestions();
        }
      });
    }
    
    //////////////////////////////////////////////////////////////////////////////////
    // [ ÿ•ÿ∂ÿßŸÅÿ© ÿØÿßŸÑÿ© updateAllQuestionIds() ]
    //////////////////////////////////////////////////////////////////////////////////
    function updateAllQuestionIds() {
      let subtopicSelect = document.getElementById('subtopicSelect');
      if (!subtopicSelect || subtopicSelect.selectedIndex < 0) return;
      let optionText = subtopicSelect.options[subtopicSelect.selectedIndex].text;
      let parts = optionText.match(/^\[(.+)\]\s*-\s*(.+)$/);
      let topicName = parts ? parts[1].trim() : "";
      let subtopicName = parts ? parts[2].trim() : "";
      let topicPart = topicName.toLowerCase().substring(0, 4);
      let subPart = subtopicName.toLowerCase().substring(0, 3);
      
      for (let i = 0; i < currentQuestions.length; i++) {
        currentQuestions[i].id = `${topicPart}-${subPart}-q${i + 1}`;
      }
      console.log("Updated question IDs:", currentQuestions.map(q => q.id));
    }
    //////////////////////////////////////////////////////////////////////////////////
    // [ ŸÜŸáÿßŸäÿ© ÿØÿßŸÑÿ© updateAllQuestionIds() ]
    //////////////////////////////////////////////////////////////////////////////////
    
    async function convertAndAppend(){
      if(!currentSubtopicPath) return;
      let prefix = document.getElementById('prefixInput').value.trim();
      let startNumber = parseInt(document.getElementById('startQNumber').value, 10);
      if(isNaN(startNumber) || startNumber < 1) startNumber = 1;
    
      let text = document.getElementById('questionsText').value.trim();
      if(!text) return;
    
      let arr = null;
      try{
        if(text.startsWith('let quizData =')){
          text = text.replace('let quizData =','').trim();
          if(text.endsWith(';')) text = text.slice(0,-1);
        }
        arr = JSON.parse(text);
        if(Array.isArray(arr)){
          await handleImagesAndBind(arr);
          currentQuestions = currentQuestions.concat(arr);
          updateAllQuestionIds();
          renderEditableQuestions();
          alert("Conversion completed!");
          return;
        }
      } catch(e){}
      let lines = text.split('\n');
      let questionText = null, options = [], ansIdx = -1, ansText = null, explanation = null;
      let out = [];
      for(let i = 0; i < lines.length; i++){
        let ln = lines[i].trim();
        let qM = ln.match(/^(\d+)\.\s+(.*)/);
        if(qM){
          if(questionText !== null){
            out.push({question: questionText, options, answer: ansIdx, answerText: ansText, explanation, userAnswer: null});
          }
          questionText = `<span style='color: darkred; font-weight:bold;'>${prefix ? prefix + ' ' : ''}Question ${startNumber}</span> ${qM[2]}`;
          startNumber++;
          options = []; ansIdx = -1; ansText = null; explanation = null;
        } else {
          let opt = ln.match(/^([A-F])\.\s+(.*)/i);
          if(opt){
            let txt = opt[2].trim();
            if(txt.endsWith('***')){
              txt = txt.slice(0,-3).trim();
              ansIdx = options.length;
              ansText = txt;
            }
            options.push(txt);
          } else {
            let ex = ln.match(/^Explanation\s*:\s*(.*)/i);
            if(ex){
              explanation = ex[1];
            }
          }
        }
      }
      if(questionText !== null){
        out.push({question: questionText, options, answer: ansIdx, answerText: ansText, explanation, userAnswer: null});
      }
      await handleImagesAndBind(out);
      currentQuestions = currentQuestions.concat(out);
      updateAllQuestionIds();
      renderEditableQuestions();
      alert("Conversion completed!");
    }
    
    async function handleImagesAndBind(questionsArr){
      let c = document.getElementById('imageContainer');
      let rows = c.querySelectorAll('.image-field-row');
      let subtopicSelect = document.getElementById('subtopicSelect');
      let optionText = subtopicSelect.options[subtopicSelect.selectedIndex].text;
      let parts = optionText.match(/^\[(.+)\]\s*-\s*(.+)$/);
      let topic = parts ? parts[1].trim() : "";
      let subtopic = parts ? parts[2].trim() : "";
      
      let dataMap = {};
      for(let row of rows){
        let inputs = row.querySelectorAll('input');
        let qnum = parseInt(inputs[0].value, 10);
        if(!qnum) continue;
        let fileIn = inputs[1];
        if(fileIn.files && fileIn.files.length > 0){
          let file = fileIn.files[0];
          let prog = row.querySelector('.progress');
          let pbar = prog.querySelector('.progress-bar');
          let result = await uploadImageToGitHub(file, prog, pbar, { questionNumber: qnum, topic, subtopic });
          if(result.url){
            if(!dataMap[qnum]) dataMap[qnum] = [];
            dataMap[qnum].push(`<br><img src='${result.url}' alt='Image for Q${qnum}' style='max-width:100%; height:auto;' data-filepath='${result.filePath}'>`);
          }
        }
      }
      questionsArr.forEach(obj => {
        let match = obj.question.match(/Question\s+(\d+)/);
        if(match){
          let qn = parseInt(match[1], 10);
          if(dataMap[qn]){
            dataMap[qn].forEach(imgHtml => {
              obj.question += imgHtml;
            });
          }
        }
      });
    }
    
    function uploadImageToGitHub(file, progressContainer, progressBar, extraParams) {
      return new Promise((resolve) => {
        if (!file) {
          return resolve({url:"", filePath:""});
        }
        if (progressContainer) {
          progressContainer.style.display = "block";
        }
        if (progressBar) {
          progressBar.style.width = "0%";
          progressBar.textContent = "0%";
        }
        const reader = new FileReader();
        reader.onload = async function() {
          const base64 = reader.result.split(',')[1];
          progressBar.style.width = "50%";
          progressBar.textContent = "Uploading";
          try {
            let payload = { 
              name: file.name, 
              base64: base64 
            };
            if(extraParams){
              payload.topic = extraParams.topic;
              payload.subtopic = extraParams.subtopic;
              payload.questionNumber = extraParams.questionNumber;
            }
            const response = await fetch('/api/upload-image', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            const result = await response.json();
            if(result.success) {
              progressBar.style.width = "100%";
              progressBar.textContent = "Uploaded";
              resolve({url: result.url, filePath: result.filePath});
            } else {
              console.error("Image upload failed:", result.error);
              progressBar.textContent = "Failed";
              resolve({url: "", filePath: ""});
            }
          } catch(e) {
            console.error("Error uploading image:", e);
            progressBar.textContent = "Failed";
            resolve({url: "", filePath: ""});
          }
        };
        reader.readAsDataURL(file);
      });
    }
    
    // Bulk Reorder Functions (example for moveGroupUp and moveGroupDown)
    function moveGroupUp(groupTitle) {
      const groups = detectBoldGroups();
      groups.sort((a, b) => Math.min(...a.indices) - Math.min(...b.indices));
      const targetIndex = groups.findIndex(g => g.title === groupTitle);
      if(targetIndex <= 0) return;
      const prevGroup = groups[targetIndex - 1];
      const targetGroup = groups[targetIndex];
      const prevStart = Math.min(...prevGroup.indices);
      const prevEnd = Math.max(...prevGroup.indices);
      const targetStart = Math.min(...targetGroup.indices);
      const targetEnd = Math.max(...targetGroup.indices);
    
      const before = currentQuestions.slice(0, prevStart);
      const blockPrev = currentQuestions.slice(prevStart, prevEnd + 1);
      const middle = currentQuestions.slice(prevEnd + 1, targetStart);
      const blockTarget = currentQuestions.slice(targetStart, targetEnd + 1);
      const after = currentQuestions.slice(targetEnd + 1);
    
      currentQuestions = before.concat(blockTarget, middle, blockPrev, after);
      updateAllQuestionIds();
      renderEditableQuestions();
      loadBoldGroups();
    }
    
    function moveGroupDown(groupTitle) {
      const groups = detectBoldGroups();
      groups.sort((a, b) => Math.min(...a.indices) - Math.min(...b.indices));
      const targetIndex = groups.findIndex(g => g.title === groupTitle);
      if(targetIndex === -1 || targetIndex === groups.length - 1) return;
      const targetGroup = groups[targetIndex];
      const nextGroup = groups[targetIndex + 1];
      const targetStart = Math.min(...targetGroup.indices);
      const targetEnd = Math.max(...targetGroup.indices);
      const nextStart = Math.min(...nextGroup.indices);
      const nextEnd = Math.max(...nextGroup.indices);
    
      const before = currentQuestions.slice(0, targetStart);
      const blockTarget = currentQuestions.slice(targetStart, targetEnd + 1);
      const middle = currentQuestions.slice(targetEnd + 1, nextStart);
      const blockNext = currentQuestions.slice(nextStart, nextEnd + 1);
      const after = currentQuestions.slice(nextEnd + 1);
    
      currentQuestions = before.concat(blockNext, middle, blockTarget, after);
      updateAllQuestionIds();
      renderEditableQuestions();
      loadBoldGroups();
    }
    
    function detectBoldGroups() {
      const groups = [];
      const regex = /<span\s+style=(["'])(?:(?!\1).)*font-weight:\s*bold;?(?:(?!\1).)*\1>(.*?)<\/span>/i;
      currentQuestions.forEach((q, index) => {
        const match = q.question.match(regex);
        if(match) {
          let boldContent = match[2];
          let parts = boldContent.split(/- Question/i);
          if(parts.length > 0) {
            let groupName = parts[0].trim();
            if(groupName) {
              let existing = groups.find(g => g.title === groupName);
              if(existing) {
                existing.indices.push(index);
              } else {
                groups.push({ title: groupName, indices: [index] });
              }
            }
          }
        }
      });
      groups.sort((a, b) => Math.min(...a.indices) - Math.min(...b.indices));
      return groups;
    }
    
    async function loadBoldGroups() {
      try {
        if (!currentSubtopicPath) {
          alert("Please select and load a subtopic first!");
          return;
        }
        const boldGroups = detectBoldGroups();
        if(boldGroups.length === 0) {
          alert("No groups found! Ensure questions have this format:\n<span style='color: darkred; font-weight:bold;'>Group Name - Question X</span>");
          return;
        }
        renderBoldGroups(boldGroups);
      } catch (error) {
        console.error("Load Bold Groups Error:", error);
        alert("Error loading groups. Check console.");
      }
    }
    
    async function deleteGroup(groupTitle) {
      let conf = await confirm("Are you sure you want to delete this group of questions?");
      if(!conf) return;
      let groups = detectBoldGroups();
      let targetGroup = groups.find(g => g.title === groupTitle);
      if(!targetGroup) return;
      let indicesToDelete = targetGroup.indices.sort((a, b) => b - a);
      indicesToDelete.forEach(i => {
        currentQuestions.splice(i, 1);
      });
      updateAllQuestionIds();
      renderEditableQuestions();
      loadBoldGroups();
    }
    
    function jumpToQuestion() {
      let qNum = parseInt(document.getElementById('jumpToQuestion').value);
      if(isNaN(qNum) || qNum < 1 || qNum > currentQuestions.length) return;
      let target = document.getElementById(`q-${qNum}`);
      if(target){
        target.scrollIntoView({behavior: 'smooth', block: 'start'});
        target.style.background = '#fff3e0';
        setTimeout(() => target.style.background = '', 2000);
      }
    }
  </script>
</body>
</html>
